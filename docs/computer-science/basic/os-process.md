---
series: 操作系统原理
title: 操作系统的进程管理
enable html: true
categories: Basic
tags:
  - Operating System
  - Process
date: 2019-11-02 20:09:05
---

本篇介绍操作系统中进程的管理机制、调度机制、同步机制和通信机制。进程作为操作系统中资源分配与管理的基本单位，是操作系统运行的重要组成部分。现代操作系统为了提升运行效率，使用了诸多调度算法来为进程安排 CPU 时间。为了协调多进程的工作并对相关进程进行同步，计算机科学家对进程模型进行了相当的抽象。

<!-- more -->

## 进程与线程

### 进程与线程

1. **进程**

   进程是操作系统资源分配的最基本单位。进程控制块 (PCB, Process Control Pack) 描述了进程的基本信息和运行状态。所谓创建进程和撤销进程，都是指对进程控制块的操作。

2. **线程**

   线程是操作系统中能够独立调度的最小单位。一个进程中可能有多个线程，这些线程共享着这个进程的资源。

### 进程与线程的区别

1. **关于资源**

   进程独立拥有资源。而线程不独立拥有资源，只能访问所隶属的进程的资源。

2. **关于调度**

   在同一进程中，线程的切换不会触发进程切换。而从一个进程中的某个线程切换到另一个进程中的线程时会引起进程切换。

3. **关于系统开销**

   创建或撤销进程时，系统要为进程分配及回收资源，如内存空间，输入输出设备等，付出的开销远大于创建或撤销线程的开销。进程切换时，操作系统需要保存当前 CPU 上下文，并设置新线程的 CPU 上下文。线程切换时，只需要保存和设置少数寄存器的内容，开销较小。

4. **关于通信**

   进程间通信需要进程同步和互斥手段作为辅助，以保证数据的一致性。线程间通信可以通过直接访问同一进程中的数据段进行通信。

### 进程的状态

只有就绪态和运行态可以相互切换，其他状态间只允许单项切换。

<div align="center">  
<img
    src="https://images.herculas.cn/image/blog/basic/os/process/os-processstate.png"
    width="60%"
    alt="进程的状态"
/>
</div>

就绪态进程通过调度算法获得 CPU 时间，转化为运行态；运行态进程在耗尽 CPU 时间后回落到就绪态。运行态的进程因缺少必要的运行资源而转化到阻塞态，当资源到位后重新回到就绪态等待新一轮调度。

## 处理机调度

### 批处理系统的调度

1. **先来先服务** (FCFS, First Come First Served)

   先来先服务调度算法会调度最先进入就绪队列的作业。这有利于长作业，但不利于短作业。因为短作业必须一直等待前面的长作业执行完毕才能执行，导致短作业的平均等待时间过长。

2. **最短作业优先** (SJF, Shortest Job First)

   最短作业优先调度算法会调度估计运行时间最短的作业。这使得长作业可能永远等不到被执行的机会。

3. **最短剩余时间优先** (SRTN, Shortest Remaining Time Next)

   最短剩余时间优先调度算法会调度剩余运行时间最短的作业。当一个新作业入栈时，将其全部运行执行时间与当前作业剩余时间相比较，若新作业时间更短，则挂起当前作业转而执行新作业。该调度方法可以使新的短作业获得更好的服务。

### 交互式系统的调度

1. **轮转调度** (Round Robin)

   轮转调度为每个进程分配一个时间段，称为时间片 (quantum)。若时间片结束时进程尚未执行完毕，则挂起该进程，将 CPU 时间分配给另一个进程。若进程在时间片结束之前阻塞或结束，则立即切换进程。

2. **优先级调度**

   优先级调度为每个进程赋予一个优先级，并允许高优先级的进程先执行。在操作中可以将响应比作为优先级，此时该调度方法称为高响应比优先调度算法 (HRRN, Highest Response Ratio Next)。
   
   假设进程的要求服务时间为 $T_{serv}$，等待时间为 $T_{wait}$，那么进程的总响应时间为 $T_{res} = T_{serv} + T_{wait}$。该进程的相应比为：
   $$
   R = \frac{T_{serv} + T_{wait}}{T_{serv}} = \frac{T_{res}}{T_{serv}}
   $$
   该调度算法主要解决了最短作业优先调度算法中长作业有很大概率被饿死的问题。随着长作业的等待时间的增加，其响应比也随之升高，调度优先级也会随之提升。

3. **多级反馈队列**

   在轮转调度算法中，若一个进程需要执行 100 个时间片，那么该进程需要被交换出 CPU 执行环境 100 次以上。多级队列针对这种需要连续执行多个时间片的进程设计。该算法设置了多个队列，每个队列的时间片大小都不相同，并依次递增，如 1, 2, 4, 8, ... 。进程如果在第一个时间队列没有执行完，就会被移到下一个队列。
   
   <div align="center">  
   <img
       src="https://images.herculas.cn/image/blog/basic/os/process/os-queue.png"
       width="40%"
       alt="多级反馈队列"
   />
   </div>
   
   上述每个队列的优先级也不同，最上面队列的优先级最高。

### 实时系统的调度

实时系统要求一个服务请求在有限时间之内必须得到响应。实时系统分为硬实时和软实时，其中硬实时必须满足绝对的截止时间，而软实时可以容忍一定的超时。

## 进程同步

### 竞争条件

竞争条件 (Race Condition) 指两个或多个进程读取某个共享数据，而所有操作的最终结果取决于进程执行的精确时序的情况。

### 临界区

为了避免竞争条件，需要阻止多进程同时访问共享数据，即互斥访问 (Mutual Exclusion)。以某种手段确保当一个进程访问一个共享的变量或内存空间时，其他进程不能做同样的操作。一般称对共享内存进行访问的程序片段成为临界区 (Critical Section)。

<div align="center">  
<img
    src="https://images.herculas.cn/image/blog/basic/os/process/critical-section.png"
    width="70%"
    alt="临界区"
/>
</div>

为了确保进程的高效调度，良好的解决方案应该满足：

- 任意两个进程不能同时处于同一临界区；
- 不应对 CPU 的运行速度和数量作任何假设；
- 临界区外的进程不得阻塞其他进程进入临界区；
- 不得使进程无限期等待进入临界区。

### 同步与互斥

同步指多个进程按一定顺序执行，互斥指多个进程在同一时刻最多只能有一个处于临界区。

### 信号量

信号量 (Semaphore) 是一个整型数，仅支持两个操作：down 和 up。

- down 操作检查信号量是否大于 0，若大于 0 则把该信号量的值减 1；若信号量的值为 0，则不进行任何操作。
- up 操作对信号量加 1 。

有一种特殊的信号量称为互斥量 (Mutex)，互斥量只能取 0 和 1 两个值。通常在使用中，0 代表临界区被加锁，1 代表临界区可进入。

### 管程

使用信号量机制需要特别注意控制信号的顺序问题。管程 (Monitor) 将对信号量的控制代码独立出来，使对其的调用更加容易。管程有一个重要的特性，在任意时间点上只能有一个活跃进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。

管程引入条件变量 (Condition Variables) 及相关操作 `wait()` 和 `signal()`。当一个管程发现其无法继续运行时，会在某个条件变量上执行 `wait()` 操作。该操作导致调用进程自身阻塞，并将另一个等待在管程之外的进程调入管程。其他进程可以通过对正在睡眠的伙伴进程的处于等待状态的条件变量执行 `signal()` 操作来唤起该进程。

### 屏障

屏障 (Barrier) 机制通常被用于进程组。有些应用场景规定除非所有进程都进入就绪状态，任何进程都不能独自进入下一运行阶段。可以通过在每个阶段的末尾安置屏障来实现该要求。当一个进程到达屏障时，该进程即被拦截，直到所有进程都到达该屏障。

## 经典进程同步问题

### 生产者-消费者问题

两个进程共享一个公共的固定大小的缓冲区，其中一个被称为生产者，他将消息放入缓冲区；另一个是消费者，他从缓冲区取出消息。

当缓冲区已满，但生产者仍想放入消息时，生产者将会被休眠，直到消费者消费消息导致缓冲区有空闲时将生产者唤醒。当缓冲区为空，但消费者仍想取出消息时，消费者将会被休眠，直到生产者向缓冲区中放入新消息将消费者唤醒。

**使用信号量实现生产者-消费者问题**

1. 缓冲区属于临界资源，可以使用一个互斥量 `mutex` 来控制对缓冲区的互斥访问。
2. 为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：`empty`  记录空缓冲区的数量，`full`记录满缓冲区的数量。其中，`empty` 信号量是在生产者进程中使用，当 `empty` 不为 0  时，生产者才可以放入物品；`full` 信号量是在消费者进程中使用，当 `full` 信号量不为 0 时，消费者才可以取走物品。
3. 不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 `down(mutex)` 再执行  `down(empty)`。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 `down(empty)` 操作，发现 `empty =  0`，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 `up(empty)` 操作，`empty` 永远都为  0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。

### 哲学家就餐问题

若干个哲学家坐在一张圆桌周围，每个哲学家面前放着食物。哲学家的生活只有 2 中交替活动：进食和思考。当一个哲学家进食时，他必须分两次取其左右两边的筷子，每次一根，不分顺序。若哲学家成功取得一双筷子，则他可以开始进食，进食完毕后他放下筷子继续思考。

<div align="center">  
<img
    src="https://images.herculas.cn/image/blog/basic/os/process/os-philospher.jpg"
    width="30%"
    alt="哲学家就餐问题"
/>
</div>

使用信号量可以解决该问题：

- 使用数组 state 跟踪每个哲学家的状态，分为正在进食，正在思考或试图拿筷子；
- 一个哲学家只有在两个邻居都未在进食时才能允许进入进食状态；
- 每个信号量对应一个哲学家，当筷子被占用时，该哲学家进入阻塞状态。

### 读者-写者问题

考察一个数据库系统，有许多竞争的进程在试图访问数据。多个进程同时读数据是可以接受的，但若有一个进程在写入数据，则所有其余进程都不允许访问数据库。

使用信号量可以解决该问题：

- 使用整型数 count 统计进行读操作的进程数；
- 使用互斥量 count_mutex 用于对 count 加锁；
- 使用互斥量 data_mutex 用于对被读写的数据加锁；
- 在一个读者访问数据，而该数据此时有一个写者正在访问时，新读者被挂起；
- 在一个写者访问数据，而该数据此时有若干个读者正在访问时，该写者只需等待正在访问的读者，而不必等候他后面的读者。

## 进程间通信

进程间通信 (IPC, Inter-Process Communication)很容易与进程同步相混淆，其区别在于：

- 进程间通信用于在进程间传输消息；
- 进程同步用于控制多个进程按一定顺序执行，协调多个进程完成任务。

### 无名管道

通过调用 `pipe()`函数创建无名管道。

```c
#include<unistd.h>
int pipe(int fd[2]);
```

管道维护两个文件描述符，其中 `fd[0]` 用于读操作，`fd[1]` 用于写操作。无名管道只支持半双工通信，且只能在父子进程或兄弟进程中使用。

### 命名管道

命名管道去除了无名管道只能在父子进程或兄弟进程中使用的限制。

```c
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
```

命名管道常用于 C/S 架构的应用程序中，作为汇聚点在客户端进程和服务器进程之间传递数据。

### 消息队列

相比于管道，消息队列有以下优点：

1. 消息队列可以独立于读写进程存在，从而避免了同步管道的打开和关闭时可能产生的困难；
2. 避免了管道的同步阻塞问题，不需要进程自己提供同步方法；
3. 读进程可以根据消息类型有选择地接收消息，而不像命名管道那样只能默认接收。

### 共享内存

允许多个进程共享一个指定的内存区域。因为数据不需要在进程之间复制，所以这是最快的一种 IPC 机制。多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。

### 套接字

套接字可用于不同机器间的进程通信。

## 死锁

若一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，则该进程集合陷入死锁状态。在死锁状态中，进程集合中的每个进程都在无线等待其他进程正在持有的资源。

### 死锁的条件

进程死锁有四个主要条件：

1. **互斥条件**：每个资源要么已经分配给了某个进程，要么处于可用状态；
2. **占有和等待条件**：已经得到某个资源的进程还可以请求其他资源；
3. **不可抢占条件**：已经分配给一个进程的资源不能强制性地被其他进程抢占，除非占有它的进程主动放弃对该资源的持有；
4. **环路等待条件**：死锁发生时，系统中一定有至少两个进程组成了一条环路。在该环路中，每个进程都在等待下一进程所占有的资源。

倘若用圆形表示进程，用方块表示资源，用资源节点到进程节点的有向边表示资源和进程的关系，那么下图可以表达一个进程死锁的情况：

<div align="center">  
<img
    src="https://images.herculas.cn/image/blog/basic/os/process/os-deadlock.png"
    width="60%"
    alt="死锁"
/>
</div>

### 死锁的处理策略

1. **鸵鸟策略**

   把头埋进沙子里，假装无事发生。如果死锁的解决代价很高，而不采取任何措施可能会得到更好的结果。又或者发生死锁时不会对用户发生太大影响，或者死锁的概率很低，可以采用鸵鸟策略。

2. **死锁检测**

   不试图阻止死锁的产生，而是当检测到死锁发生时才采取措施将其恢复。
   
   - 每种类型一个资源
   
     为系统构造资源分配图，若图中包含一个或多个环，那么存在死锁。依次将每一个节点作为一棵树的根节点，进行深度优先搜索，若再次遇到已经遭遇过的节点，就找到了一个环路。
   
     <div align="center">  
     <img
         src="https://images.herculas.cn/image/blog/basic/os/process/os-deadlock2.png"
         width="60%"
         alt="每种类型一个资源"
     />
     </div>
   
   - 每种类型多个资源
   
     设资源类型有 $m$ 种，$E$ 是现有资源向量(Existing Resource Vector)，代表已存在的资源总数。$A$ 是可用资源向量 (Available Resource Vector)，代表当前可用的资源数，即未被分配的资源数。$C$ 是当前分配矩阵 (Current Allocation Matrix)，每行代表一个进程持有的资源数。$R$ 是请求矩阵 (Request Matrix)，每行代表一个进程请求的资源数。
     $$
     E = [E_1, E_2, E_3, \cdots, E_m]
     $$
   
     $$
     A = [A_1, A_2, A_3, \cdots, A_m]
     $$
   
     $$
     C = 
     \begin{bmatrix} 
     C_{11} & C_{12} & C_{13} & \cdots & C_{1m} \\
     C_{21} & C_{22} & C_{23} & \cdots & C_{2m} \\ 
     \vdots & \vdots & \vdots & \ddots & \vdots \\
     C_{n1} & C_{n2} & C_{n3} & \cdots & C_{nm}
     \end{bmatrix}
     $$
   
     $$
     R = 
     \begin{bmatrix} 
     R_{11} & R_{12} & R_{13} & \cdots & R_{1m} \\
     R_{21} & R_{22} & R_{23} & \cdots & R_{2m} \\ 
     \vdots & \vdots & \vdots & \ddots & \vdots \\
     R_{n1} & R_{n2} & R_{n3} & \cdots & R_{nm}
     \end{bmatrix}
     $$
   
     那么这些数据之间有如下关系：
     $$
     \sum_{i=1}^{n}C_{ij} + A_j = E_j
     $$
     可按照如下方法检测死锁：
   
     - 寻找一个未标记的进程 $P_i$，对该进程而言矩阵 $R$ 的第 $i$ 行向量小于等于 $A$；
     - 若找到这样的进程，则将矩阵 $C$ 的第 $i$ 行加到 $A$ 中，标记进程 $P_i$，并转到上一步；
     - 若没有这样的进程，终止算法；
     - 算法结束时，所有未被标记过的进程都是死锁进程。

### 死锁的避免与预防

1. **死锁避免**

   - **安全状态**

     如果没有死锁发生，并且即使所有进程都突然请求对资源的最大需求，也仍存在某种调度次序使得每个进程都能运行完毕，则称该状态为安全状态。

     <div align="center">  
     <img
         src="https://images.herculas.cn/image/blog/basic/os/process/os-deadlock4.png"
         width="80%"
         alt="安全状态"
     />
     </div>

   - **单个资源的银行家算法**

     设想这样一个场景，银行家向一群客户承诺一定的贷款额度。算法需要判断对请求的满足是否会使银行家进入不安全状态（即资金无法周转）。若是则拒绝贷款请求，若否则予以贷款。

     <div align="center">  
     <img
         src="https://images.herculas.cn/image/blog/basic/os/process/os-deadlock5.png"
         width="70%"
         alt="单个资源的银行家算法"
     />
     </div>

   - **多个资源的银行家算法**

     在多个资源的情况下检测一个状态是否安全的算法：

     - 查找右矩阵是否有一行小于等于 $A$，若不存在则系统将死锁，状态不安全；
     - 假若找到这样一行，将该进程标记终止，并将其已分配资源释放给 $A$；
     - 重复上面两步，直至所有进程都被标记为终止，则状态是安全的。
     
     <div align="center">  
     <img
         src="https://images.herculas.cn/image/blog/basic/os/process/os-deadlock6.png"
         width="60%"
         alt="多个资源的银行家算法"
     />
     </div>

2. **死锁预防**

   死锁避免从本质上是不可能的，因为需要获知未来的请求才能实现预测，而这些请求不可预知。只能在程序运行前预防死锁的发生，通过保证下面的四个条件中至少一个不成立以预防死锁：
   
   - 破坏互斥条件
   - 破坏占有和等待条件
   - 破坏不可抢占条件
   - 破坏环路等待条件

## 参考文献

1. [Andrew S. Tanenbaum. 现代操作系统 (第3版).](https://book.douban.com/subject/3852290/)
2. [CyC2018. 计算机操作系统-进程管理.](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md)
3. [CyC2018. 计算机操作系统-死锁.](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%AD%BB%E9%94%81.md)
