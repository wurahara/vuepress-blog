---
series: 数据库系统理论
title: 关系型数据库设计及其规范化
enable html: true
categories: Basic
tags:
  - Database
date: 2018-05-26 18:28:50
---


在目前使用的数据库及其管理软件中，关系型数据库占据了统治地位。关系型数据库基于 E. F. Codd 于1970年提出的[关系数据模型](https://www2.cs.duke.edu/courses/cps216/spring05/papers/codd-1970.pdf)理论。在关系模型中，所有数据逻辑都被组织成关系（表）的结构。关系模型的逻辑结构简单明晰，但其结构却有可靠的理论基础。Codd 的论文构建关系模型的目标是：

- 实现高度的数据独立性。更改内部数据的表示方式，特别是当文件的组织方式、记录顺序及访问路径发生更改时，应用程序不受影响。
- 提供坚实的理论基础，用以处理数据语义、一致性和冗余问题，提出规范化的概念。
- 扩展面向网络的数据操作语言(DML, Data Manipulation Language)。

<!-- more -->

## 关系模型的基本术语

### 关系数据结构

- __关系(Relation)__：由行和列组成的数据表；
- __属性(Attribute)__：关系中命名的列，又被称为字段(Field)；
- __域(Domain)__：一个或多个属性的取值集合；
- __元组(Tuple)__：关系中的行，又被称为记录(Record)。

### 码与关键字
- __超码(Superkey)__：一个或多个属性的集合，这些属性的组合可以在一个关系中唯一的标识一个元组；
- __候选码(Candidate Key)__：任意真子集都不能成为超码的最小超码集合；
- __主码(Primary Key)__：被数据库设计者选中的，用于在一个关系中区分不同元组的候选码；
- __外码(Foreign Key)__：一个关系模式 $r_1$ 可能在其属性中包含另一关系模式 $r_2$ 的主码，该属性在 $r_1$ 中称作参照 $r_2$ 的外码。关系 $r_1$ 称作外码依赖的 __参照关系(Referencing Relation)__ ，$r_2$ 称作 __被参照关系(Referenced Relation)__ 。

## 规范化(Normalization)

### 数据冗余与更新异常

关系型数据库设计的主要目标之一就是将属性组合成关系时尽量减少数据冗余。这一目标的实现有以下意义：
- 可以用最少的操作完成对数据库中数据的更新，由此可以降低数据不一致的概率；
- 减少存储基本关系所需的文件存储空间，进而降低存储成本。

更新存在冗余数据的关系可能会触发更新异常。更新异常又可分为插入异常，删除异常和修改异常。

1. __插入异常(Insertion Anomaly)__

这种异常是指当用户想要插入某一真实世界的实体数据时，还必须输入另一个真实世界中实体的数据。

2. __删除异常(Deletion Anomaly)__

这种异常是指当用户要删除某一真实世界的实体数据时，还必须删除另一个真实世界中实体的数据。

3. __修改异常(Modification Anomaly)__

这种异常是指当用户要修改某个值的时候，同样的修改操作需要重复多次。

### 函数依赖

上述的这些更新异常，都可通过规范化设计的方式避免。在详细介绍规范化设计之前，首先来讨论一个重要的概念：__函数依赖(Functional Dependency)__。

函数依赖，是指关系中属性之间的联系。假设 A 和 B 都是关系 R 的属性，若 A 的每个值都和 B 中的一个唯一值相对应，则称 B 函数依赖于 A ，或称 A 函数决定 B ，其中 A 称为 __决定方(Determinant)__。

常见的函数依赖类型有：

1. __部分函数依赖(Partial Functional Dependency)__

假设 A 和 B 是某一关系的属性或属性集合，若 B 函数依赖于 A 的一个部分，则称 B 部分函数依赖于 A 。

2. __完全函数依赖(Full Functional Dependency)__

假设 A 和 B 是某一关系的属性或属性集合，若 B 函数依赖于 A ， 但不函数依赖于 A 的任一真子集，则称 B 完全函数依赖于 A 。在关系模型中，完全依赖指复合主码可以唯一确定关系中的其他属性，但复合主码的任意真子集合都不能实现同样目的。

3. __传递函数依赖(Transitive Functional Dependency)__

假设 A 、B 、C 是某一关系的属性，若 B 函数依赖于 A ，C 函数依赖于 B ，则称 C 通过 B 传递函数依赖于 A 。

### 数据库规范化

Codd 指出，规范化是一种基于关系的主码（或候选码）和函数依赖对关系进行分析的形式化技术。规范化涉及到一系列的规则，这些规则能够用来对关系进行单独测试以保证数据库可以被规范化到任意程度。当某种规范化的要求未能得到满足时，就将违反需求的关系分解为多个关系，直至分解后的每一个关系都能满足规范化要求为止。

最早，Codd提出了三个范式，分别为第一范式(1NF)，第二范式(2NF)和第三范式(3NF)。后来，R. Boyce 和 E. F. Codd 又提出了一种强于第三范式的新范式，称为 Boyce-Codd 范式(BCNF)。之后，更强于 BCNF 的第四范式(4NF)和第五范式(5NF)相继出现。然而，需要实现第四范式、第五范式的情况相当少。因此，绝大多数讨论主要集中在前三种范式上。

1. 第一范式(1NF)
<center> __每一行与每一列相交的位置有且只有一个值的关系，满足第一范式。__ </center>
为了将非规范化的表转化为满足第一范式的数据表，我们需要确定并删除表中的重复组。一个重复组可以是一个或一组属性，对应表的某个候选码的一个实例可能出现多个值。从非规范化表中删除重复组的常用方法有两种：

    1. 在含有重复数据的行的空白列上输入合适的数据，即在需要填充的位置复制非重复数据。该方法通常被称为对表的平板化处理(Flattening)。
    2. 将重复的数据单独移动到一个新的关系中，并将原来关系中的主码复制到该新关系中。有时候，非规范化的表中可能包含多个重复组，或在重复组中还包含有重复组。在这种情况下，重复使用该方法直至不再存在重复组为止。


2. 第二范式(2NF)
<center> __满足第一范式且所有非主码属性都完全函数依赖于主码的关系，满足第二范式。__ </center>
第二范式仅适用于具有合成码的关系，即主码有两个或以上属性构成的关系。主码仅包含一个属性的关系只要满足1NF，则必然是2NF的。不是2NF的关系可能会出现之前讨论的更新异常。将1NF关系增强到2NF，需要消除关系中的部分函数依赖。如果关系中存在部分函数依赖，就把部分依赖的属性从原关系中迁出，移动到新的关系中，同时将这些属性的决定方也复制到新关系中。

3. 第三范式(3NF)
<center> __满足第二范式且所有非主码属性都不传递函数依赖于主码的关系，满足第三范式。__ </center>
将2NF关系增强到3NF，需要消除关系中的传递函数依赖。如果关系中存在传递函数依赖，就把传递依赖的属性或属性集合移到新的关系中，并将这些属性的决定方也复制到该关系中。

## 参考文献

1. [ Codd, E. F. (June 1970). "A Relational Model of Data for Large Shared Data Banks". Communications of the ACM. 13 (6): 377–387. doi:10.1145/362384.362685.](https://www2.cs.duke.edu/courses/cps216/spring05/papers/codd-1970.pdf)
2. Codd, E. F. "Recent Investigations into Relational Data Base Systems." IBM Research Report RJ1385 (April 23, 1974). Republished in Proc. 1974 Congress (Stockholm, Sweden, 1974). New York, N.Y.: North-Holland (1974).
3. [Peter Rob, Carlos Coronel. 数据库系统：设计、实现与管理 (第8版).](https://book.douban.com/subject/15994778/)
4. [Abraham Silberschatz, Henry F.Korth, S.Sudarshan. 数据库系统概念 (第6版).](https://book.douban.com/subject/10548379/)
